[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "add_log",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "add_log",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "clear_logs",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "get_logs",
        "importPath": "app.logger",
        "description": "app.logger",
        "isExtraImport": true,
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "const",
        "importPath": "app.services",
        "description": "app.services",
        "isExtraImport": true,
        "detail": "app.services",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "app.services",
        "description": "app.services",
        "isExtraImport": true,
        "detail": "app.services",
        "documentation": {}
    },
    {
        "label": "const",
        "importPath": "app.services",
        "description": "app.services",
        "isExtraImport": true,
        "detail": "app.services",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "app.services",
        "description": "app.services",
        "isExtraImport": true,
        "detail": "app.services",
        "documentation": {}
    },
    {
        "label": "const",
        "importPath": "app.services",
        "description": "app.services",
        "isExtraImport": true,
        "detail": "app.services",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "app.services",
        "description": "app.services",
        "isExtraImport": true,
        "detail": "app.services",
        "documentation": {}
    },
    {
        "label": "const",
        "importPath": "app.services",
        "description": "app.services",
        "isExtraImport": true,
        "detail": "app.services",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "app.services",
        "description": "app.services",
        "isExtraImport": true,
        "detail": "app.services",
        "documentation": {}
    },
    {
        "label": "html",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "html",
        "description": "html",
        "detail": "html",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "statistics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statistics",
        "description": "statistics",
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "fuzz",
        "importPath": "fuzzywuzzy",
        "description": "fuzzywuzzy",
        "isExtraImport": true,
        "detail": "fuzzywuzzy",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "current_app",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "current_app",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "create_app",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "create_app",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "create_app",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "FitnessCategory",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "FitnessCategory",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "FitnessCategory",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "app.models",
        "description": "app.models",
        "isExtraImport": true,
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "run_create_process",
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "isExtraImport": true,
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "run_update_process",
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "isExtraImport": true,
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "fetch_all_emag_products",
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "isExtraImport": true,
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "fetch_all_fitness1_products",
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "isExtraImport": true,
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "run_update_process",
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "isExtraImport": true,
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "fetch_all_fitness1_products",
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "isExtraImport": true,
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "fetch_all_fitness1_products",
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "isExtraImport": true,
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "APScheduler",
        "importPath": "flask_apscheduler",
        "description": "flask_apscheduler",
        "isExtraImport": true,
        "detail": "flask_apscheduler",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "scheduler",
        "importPath": "app.extensions",
        "description": "app.extensions",
        "isExtraImport": true,
        "detail": "app.extensions",
        "documentation": {}
    },
    {
        "label": "job_to_dict",
        "importPath": "flask_apscheduler.utils",
        "description": "flask_apscheduler.utils",
        "isExtraImport": true,
        "detail": "flask_apscheduler.utils",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "fileConfig",
        "importPath": "logging.config",
        "description": "logging.config",
        "isExtraImport": true,
        "detail": "logging.config",
        "documentation": {}
    },
    {
        "label": "context",
        "importPath": "alembic",
        "description": "alembic",
        "isExtraImport": true,
        "detail": "alembic",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "BackgroundScheduler",
        "importPath": "apscheduler.schedulers.background",
        "description": "apscheduler.schedulers.background",
        "isExtraImport": true,
        "detail": "apscheduler.schedulers.background",
        "documentation": {}
    },
    {
        "label": "EMAG_API_KEY",
        "kind": 5,
        "importPath": "app.services.const",
        "description": "app.services.const",
        "peekOfCode": "EMAG_API_KEY = os.getenv(\"EMAG_API_KEY\")\nFITNESS1_API_KEY = os.getenv(\"FITNESS1_API_KEY\")\n# Build the EMAG_HEADERS dynamically\nEMAG_HEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": f\"Basic {EMAG_API_KEY}\",\n}\nEMAG_URL = \"https://marketplace-api.emag.bg/api-3/\"\nFITNESS1_API_URL = \"https://fitness1.bg/b2b/api/products_v3\"\nFITNESS_CATEGORIES = [",
        "detail": "app.services.const",
        "documentation": {}
    },
    {
        "label": "FITNESS1_API_KEY",
        "kind": 5,
        "importPath": "app.services.const",
        "description": "app.services.const",
        "peekOfCode": "FITNESS1_API_KEY = os.getenv(\"FITNESS1_API_KEY\")\n# Build the EMAG_HEADERS dynamically\nEMAG_HEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": f\"Basic {EMAG_API_KEY}\",\n}\nEMAG_URL = \"https://marketplace-api.emag.bg/api-3/\"\nFITNESS1_API_URL = \"https://fitness1.bg/b2b/api/products_v3\"\nFITNESS_CATEGORIES = [\n    \"Спортни протектори за тяло\",",
        "detail": "app.services.const",
        "documentation": {}
    },
    {
        "label": "EMAG_HEADERS",
        "kind": 5,
        "importPath": "app.services.const",
        "description": "app.services.const",
        "peekOfCode": "EMAG_HEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": f\"Basic {EMAG_API_KEY}\",\n}\nEMAG_URL = \"https://marketplace-api.emag.bg/api-3/\"\nFITNESS1_API_URL = \"https://fitness1.bg/b2b/api/products_v3\"\nFITNESS_CATEGORIES = [\n    \"Спортни протектори за тяло\",\n    \"Шейкъри и бутилки\",\n    \"Протеини\",",
        "detail": "app.services.const",
        "documentation": {}
    },
    {
        "label": "EMAG_URL",
        "kind": 5,
        "importPath": "app.services.const",
        "description": "app.services.const",
        "peekOfCode": "EMAG_URL = \"https://marketplace-api.emag.bg/api-3/\"\nFITNESS1_API_URL = \"https://fitness1.bg/b2b/api/products_v3\"\nFITNESS_CATEGORIES = [\n    \"Спортни протектори за тяло\",\n    \"Шейкъри и бутилки\",\n    \"Протеини\",\n    \"Аминокиселини\",\n    \"Въглехидрати\",\n    \"Креатин\",\n    \"Витамини и минерали\",",
        "detail": "app.services.const",
        "documentation": {}
    },
    {
        "label": "FITNESS1_API_URL",
        "kind": 5,
        "importPath": "app.services.const",
        "description": "app.services.const",
        "peekOfCode": "FITNESS1_API_URL = \"https://fitness1.bg/b2b/api/products_v3\"\nFITNESS_CATEGORIES = [\n    \"Спортни протектори за тяло\",\n    \"Шейкъри и бутилки\",\n    \"Протеини\",\n    \"Аминокиселини\",\n    \"Въглехидрати\",\n    \"Креатин\",\n    \"Витамини и минерали\",\n    \"Продукти за отслабване и детокс\",",
        "detail": "app.services.const",
        "documentation": {}
    },
    {
        "label": "FITNESS_CATEGORIES",
        "kind": 5,
        "importPath": "app.services.const",
        "description": "app.services.const",
        "peekOfCode": "FITNESS_CATEGORIES = [\n    \"Спортни протектори за тяло\",\n    \"Шейкъри и бутилки\",\n    \"Протеини\",\n    \"Аминокиселини\",\n    \"Въглехидрати\",\n    \"Креатин\",\n    \"Витамини и минерали\",\n    \"Продукти за отслабване и детокс\",\n    \"Спортни ръкавици\",",
        "detail": "app.services.const",
        "documentation": {}
    },
    {
        "label": "THRESHLOD",
        "kind": 5,
        "importPath": "app.services.const",
        "description": "app.services.const",
        "peekOfCode": "THRESHLOD = 80\n# Create a keyword dictionary for some small categories to improve matching\nKEYWORDS_MAPPING = {\n    \"Шейкъри и бутилки\": [\"шейкър\", \"бутилка\", \"блендер бутилка\"],\n    \"Спортни протектори за тяло\": [\"протектор\"],\n    \"Протеини\": [\n        \"протеин\",\n        \"казеин\",\n        \"суроватъчен\",\n        \"телешки протеин\",",
        "detail": "app.services.const",
        "documentation": {}
    },
    {
        "label": "KEYWORDS_MAPPING",
        "kind": 5,
        "importPath": "app.services.const",
        "description": "app.services.const",
        "peekOfCode": "KEYWORDS_MAPPING = {\n    \"Шейкъри и бутилки\": [\"шейкър\", \"бутилка\", \"блендер бутилка\"],\n    \"Спортни протектори за тяло\": [\"протектор\"],\n    \"Протеини\": [\n        \"протеин\",\n        \"казеин\",\n        \"суроватъчен\",\n        \"телешки протеин\",\n        \"яйчен протеин\",\n        \"растителен протеин\",",
        "detail": "app.services.const",
        "documentation": {}
    },
    {
        "label": "fetch_all_emag_products",
        "kind": 2,
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "peekOfCode": "def fetch_all_emag_products(api_url: str, headers: dict, pause: int = 0) -> list:\n    \"\"\"\n    Fetches all products from a given API URL with pagination.\n    Args:\n        api_url (str): The API URL to query.\n        headers (dict): The headers to include in the request.\n        pause (int, optional): The number of seconds to pause between requests. Defaults to 0.\n    Returns:\n        list: A list of products fetched from the API.\n    \"\"\"",
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "fetch_all_fitness1_products",
        "kind": 2,
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "peekOfCode": "def fetch_all_fitness1_products(api_url: str, api_key: str) -> list:\n    \"\"\"\n    Fetches all products from a given API URL with a given API key.\n    Args:\n        api_url (str): The API URL to query.\n        api_key (str): The API key to include in the request.\n    Returns:\n        list: A list of products fetched from the API.\n    \"\"\"\n    response = requests.get(api_url, params={\"key\": api_key, \"description\": \"1\"})",
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "fetch_all_categories_from_categories_list_emag",
        "kind": 2,
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "peekOfCode": "def fetch_all_categories_from_categories_list_emag(\n    api_url: str, headers: dict, categories_list: list, pause: int = 0\n) -> list:\n    \"\"\"\n    Fetches all categories from a list of category IDs by making API requests.\n    Args:\n        api_url (str): The API URL to query.\n        headers (dict): The headers to include in the request.\n        categories_list (list): A list of category IDs to fetch.\n        pause (int, optional): The number of seconds to pause between requests. Defaults to 0.",
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "create_emag_product_from_fields",
        "kind": 2,
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "peekOfCode": "def create_emag_product_from_fields(\n    fitness1_product: util.Fitness1Product,\n    fitness1_related_emag_products_based_on_ean: list[dict],\n    all_emag_product_ids: list[int],\n    f1_to_emag_categories: dict,\n):\n    emag_product = util.create_emag_product_from_fitness1_product(fitness1_product)\n    if emag_product.ean in [\n        product[\"ean\"][0] for product in fitness1_related_emag_products_based_on_ean\n    ]:",
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "post_emag_product",
        "kind": 2,
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "peekOfCode": "def post_emag_product(\n    emag_product_data: list[dict],\n    api_url: str,\n    headers: dict,\n    pause=0,\n    batch_size=50,\n):\n    batched_emag_products_data = util.split_list(\n        emag_product_data, batch_size=batch_size\n    )",
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "peekOfCode": "def run():\n    all_emag_products = fetch_all_emag_products(\n        api_url=util.build_url(const.EMAG_URL, \"product_offer\", \"read\"),\n        headers=const.EMAG_HEADERS,\n        pause=1,\n    )\n    add_log(f\"Fetched {len(all_emag_products)} EMAG products\")\n    all_fitness1_products = fetch_all_fitness1_products(\n        api_url=const.FITNESS1_API_URL, api_key=const.FITNESS1_API_KEY\n    )",
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "update_emag_products",
        "kind": 2,
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "peekOfCode": "def update_emag_products(batch_size=50, pause=1):\n    all_emag_products = fetch_all_emag_products(\n        api_url=util.build_url(const.EMAG_URL, \"product_offer\", \"read\"),\n        headers=const.EMAG_HEADERS,\n        pause=1,\n    )\n    add_log(f\"Fetched {len(all_emag_products)} EMAG products\")\n    all_fitness1_products = fetch_all_fitness1_products(\n        api_url=const.FITNESS1_API_URL, api_key=const.FITNESS1_API_KEY\n    )",
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "run_create_process",
        "kind": 2,
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "peekOfCode": "def run_create_process(pause=1, batch_size=50):\n    \"\"\"\n    Executes the complete create process.\n    This function performs the following steps:\n      1. Fetches all EMAG products from the API using pagination.\n      2. Fetches all Fitness1 products.\n      3. Determines which EMAG products are related to Fitness1 products (based on EAN matching).\n      4. Fetches the current EMAG product categories and then retrieves detailed category data.\n      5. Builds a mapping between Fitness1 categories and EMAG categories.\n      6. Filters the Fitness1 products to include only those with mapped categories.",
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "run_update_process",
        "kind": 2,
        "importPath": "app.services.emag_full_seq",
        "description": "app.services.emag_full_seq",
        "peekOfCode": "def run_update_process(pause=1, batch_size=50):\n    \"\"\"\n    Executes the complete update process for EMAG products.\n    Steps:\n      1. Fetches all current EMAG products.\n      2. Fetches all Fitness1 products.\n      3. Builds a mapping between EMAG products and Fitness1 products based on EAN.\n      4. Generates updated EMAG product data.\n      5. Splits the updated data into batches.\n      6. Posts each batch and collects any failures.",
        "detail": "app.services.emag_full_seq",
        "documentation": {}
    },
    {
        "label": "Fitness1Product",
        "kind": 6,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "class Fitness1Product:\n    def __init__(\n        self,\n        brand_name,\n        product_name,\n        category,\n        image,\n        label,\n        barcode,\n        regular_price,",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "EmagResponse",
        "kind": 6,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "class EmagResponse:\n    def __init__(self, json_response: dict):\n        self._json_response = json_response\n        self.is_error: bool = json_response.get(\"isError\", False)\n        self.messages: list[str] = json_response.get(\"messages\", [])\n        self.errors: list[str] = json_response.get(\"errors\", [])\n        self.results: list = json_response.get(\"results\", [])\nclass EmagStock:\n    def __init__(self):\n        self.warehouse_id = 1",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "EmagStock",
        "kind": 6,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "class EmagStock:\n    def __init__(self):\n        self.warehouse_id = 1\n        self.value = 100\n    def to_dict(self):\n        return {\n            \"warehouse_id\": self.warehouse_id,\n            \"value\": self.value,\n        }\nclass EmagImage:",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "EmagImage",
        "kind": 6,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "class EmagImage:\n    def __init__(self, url: str, display_type: int):\n        self.url = url\n        self.display_type = display_type\n    def to_dict(self):\n        return {\n            \"url\": self.url,\n            \"display_type\": self.display_type,\n        }\nclass EmagProduct:",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "EmagProduct",
        "kind": 6,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "class EmagProduct:\n    def __init__(self):\n        self.id: int = None\n        self.category_id: int = None\n        self.ean: str = None\n        self.name: str = None\n        self.part_number: str = None\n        self.brand: str = None\n        self.images: list[EmagImage] = None\n        self.status: int = None",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "split_list",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def split_list(lst: list, batch_size=15):\n    \"\"\"\n    Example usage:\n    >> my_list = list(range(1, 251))\n    >> batches = split_list(my_list, 50)\n    >> for batch in batches:\n    >>     print(batch)\n    \"\"\"\n    return [lst[i : i + batch_size] for i in range(0, len(lst), batch_size)]\ndef get_fitness1_related_emag_products_based_on_ean(",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_fitness1_related_emag_products_based_on_ean",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_fitness1_related_emag_products_based_on_ean(\n    emag_products: list[dict], fitness1_products: list[dict]\n):\n    \"\"\"\n    Retrieves a list of eMAG products that are related to a given list of Fitness1 products.\n    Args:\n        fitness1_products (list[dict]): A list of dictionaries representing Fitness1 products,\n                                        each containing a \"barcode\" key.\n        emag_products (list[dict]): A list of dictionaries representing eMAG products,\n                                    each containing an \"ean\" key.",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "create_emag_p_to_f1_p_map",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def create_emag_p_to_f1_p_map(\n    emag_products: list[dict], fitness1_products: list[dict]\n) -> list[tuple]:\n    # Create a dictionary for quick lookup: barcode -> Fitness1 product\n    \"\"\"\n    Maps each eMAG product to its corresponding Fitness1 product based on EAN.\n    Args:\n        emag_products (list[dict]): A list of dictionaries representing eMAG products,\n                                    each containing an \"id\" and \"ean\" key.\n        fitness1_products (list[dict]): A list of dictionaries representing Fitness1 products,",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "update_emag_product_data",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def update_emag_product_data(emag_p_to_f1_p_map: list[tuple]):\n    \"\"\"\n    Updates the sale price and status of each eMAG product in the given mapping.\n    Args:\n        emag_p_to_f1_p_map (list[tuple]): A list of tuples, each containing an eMAG product ID and its corresponding Fitness1 product dictionary.\n    Returns:\n        list[dict]: A list of dictionaries, each containing the updated eMAG product data.\n    \"\"\"\n    updated_emag_product_data = []\n    for emag_p_id, f1_p in emag_p_to_f1_p_map:",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_emag_product_id_by_ean",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_emag_product_id_by_ean(ean: str, emag_products: list[dict]) -> int:\n    \"\"\"\n    Retrieves the ID of an eMAG product based on its EAN.\n    Args:\n        ean (str): The EAN of the eMAG product.\n        emag_products (list[dict]): A list of dictionaries representing eMAG products,\n                                    each containing an \"ean\" key.\n    Returns:\n        int: The ID of the eMAG product, or None if not found.\n    \"\"\"",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_emag_part_number_by_ean",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_emag_part_number_by_ean(ean: str, emag_products: list[dict]) -> str:\n    \"\"\"\n    Retrieves the part number of an eMAG product based on its EAN.\n    Args:\n        ean (str): The EAN of the eMAG product.\n        emag_products (list[dict]): A list of dictionaries representing eMAG products,\n                                    each containing an \"ean\" key.\n    Returns:\n        str: The part number of the eMAG product, or None if not found.\n    \"\"\"",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_current_emag_products_categories",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_current_emag_products_categories(emag_products: list[dict]) -> list:\n    \"\"\"\n    Retrieves a list of unique category IDs from a list of eMAG products.\n    Args:\n        emag_products (list[dict]): A list of dictionaries representing eMAG products,\n                                    each containing a \"category_id\" key.\n    Returns:\n        list: A list of unique category IDs extracted from the input products.\n    \"\"\"\n    return list(set([product[\"category_id\"] for product in emag_products]))",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_current_fitness1_categories",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_current_fitness1_categories(fitness1_products: list[dict]) -> list:\n    \"\"\"\n    Retrieves a list of unique category IDs from a list of Fitness1 products.\n    Args:\n        fitness1_products (list[dict]): A list of dictionaries representing Fitness1 products,\n                                        each containing a \"category\" key.\n    Returns:\n        list: A list of unique category IDs extracted from the input products.\n    \"\"\"\n    return list(",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "build_url",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def build_url(base_url: str, resource: str, action: str):\n    \"\"\"\n    Constructs a URL using the base URL, a given resource, and an action.\n    Args:\n        base_url (str): The EMAG API base URL\n        resource (str): The API resource (e.g., \"product_offer\", \"category\").\n        action (str): The action to perform (e.g., \"read\", \"save\").\n    Returns:\n        str: The full URL.\n    \"\"\"",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_subcategories",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_subcategories(fitness1_cat: str):\n    \"\"\"Split a fitness1 category string into subcategories (tokens).\n    Args:\n        fitness1_cat (str): The fitness1 category string to split.\n    Returns:\n        list: A list of subcategory tokens.\n    \"\"\"\n    # Split on '>' and also split on '/' if needed (since some categories have \"/\" as separators)\n    tokens = []\n    for part in fitness1_cat.split(\">\"):",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "preprocess",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def preprocess(text: str):\n    \"\"\"Lowercase and remove punctuation for normalization.\"\"\"\n    text = text.lower()\n    text = re.sub(r\"[^\\w\\s]\", \"\", text)\n    return text\ndef is_match(emag_category, token, threshold, keywords_mapping):\n    \"\"\"\n    Check if a emag category matches a given token (i.e., a substring of a fitness category)\n    by doing a fuzzy match (using both token_set_ratio and partial_ratio) and by checking\n    if the token contains any of the category's keywords.",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "is_match",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def is_match(emag_category, token, threshold, keywords_mapping):\n    \"\"\"\n    Check if a emag category matches a given token (i.e., a substring of a fitness category)\n    by doing a fuzzy match (using both token_set_ratio and partial_ratio) and by checking\n    if the token contains any of the category's keywords.\n    Parameters:\n        emag_category (str): emag category name\n        token (str): token to check\n    Returns:\n        bool: True if the token is a match, False otherwise",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "build_mapping",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def build_mapping(\n    fitness1_categories: list,\n    emag_categories: list,\n    threshold: int,\n    keywords_mapping: dict,\n):\n    \"\"\"\n    Build a dictionary mapping each emag category to a list of matching fitness1 categories.\n    Parameters:\n      - fitness1_categories: set (or list) of fitness1 category strings.",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "map_fitness1_category_to_emag_category_string",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def map_fitness1_category_to_emag_category_string(mapping: dict):\n    \"\"\"\n    Given a mapping of emag_category: [list of fitness1_categories],\n    invert it to produce a mapping of fitness1_category: emag_category\n    that matched that big category.\n    \"\"\"\n    inverse = {}\n    for emag_cat, fitness1_cat_list in mapping.items():\n        for fitness1_cat in fitness1_cat_list:\n            inverse[fitness1_cat] = emag_cat",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "map_fitness1_category_to_emag_category_data",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def map_fitness1_category_to_emag_category_data(\n    mapped_categories_strings: dict, emag_categories: list\n):\n    \"\"\"\n    Given a mapping of fitness1_category: emag_category,\n    produce a mapping of fitness1_category: emag_category_data from the emag_categories list\n    Returns a dictionary where keys are fitness1 categories and values are emag category data.\n    \"\"\"\n    f1_to_emag_cat = {}\n    for fitness1_cat, emag_cat in mapped_categories_strings.items():",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_emag_category_data_by_fitness1_category",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_emag_category_data_by_fitness1_category(\n    f1_to_emag_mapping: dict, fitness1_category: str\n) -> dict:\n    \"\"\"\n    Retrieves the emag category data corresponding to a given fitness1 category.\n    Args:\n        f1_to_emag_mapping (dict): A dictionary mapping fitness1 categories to emag categories data.\n        fitness1_category (str): The fitness1 category for which to find the corresponding emag category.\n    Returns:\n        The emag category data corresponding to the given fitness1 category, or None if not found.",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_fitness_related_emag_categories",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_fitness_related_emag_categories(\n    emag_categories: list, fitness_categories: list\n) -> dict:\n    \"\"\"\n    Gets the fitness (not fitness1) categories  from the emag categories list\n    Args:\n        emag_categories (list): The list of emag categories to map.\n        fitness_categories (list): The list of fitness categories to map.\n    Returns:\n        list: A list of emag categories that match the fitness categories.",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_fitness1_products_with_mapped_categories",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_fitness1_products_with_mapped_categories(\n    fitness1_products: list, mapped_categories_strings: dict\n):\n    \"\"\"\n    Filters a list of fitness1 products to only include those with categories that have a mapped emag category.\n    Args:\n        fitness1_products (list): The list of fitness1 products to filter.\n        mapped_categories_strings (dict): A dictionary mapping fitness1 categories to emag categories.\n    Returns:\n        list: A list of fitness1 products with categories that have a mapped emag category.",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_id_and_outliers",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_id_and_outliers(data, factor=3):\n    # Handle empty list case\n    if not data or not isinstance(data, list):\n        print(\"Empty data list provided.\")\n        return None, []\n    # Step 1: Compute the median of the data\n    median_val = statistics.median(data)\n    # Step 2: Compute absolute deviations from the median\n    deviations = [abs(x - median_val) for x in data]\n    # Step 3: Compute the median absolute deviation (MAD)",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "get_valid_emag_product_id",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def get_valid_emag_product_id(emag_products_ids: list):\n    \"\"\"\n    Returns the next available id for an emag product\n    \"\"\"\n    last_10_ids = emag_products_ids[-10:]\n    latest_id, new_id, outliers = get_id_and_outliers(last_10_ids)\n    # insert the new id next to the place of where the last_id is\n    emag_products_ids.insert(emag_products_ids.index(latest_id) + 1, new_id)\n    return new_id\ndef create_emag_product_from_fitness1_product(",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "create_emag_product_from_fitness1_product",
        "kind": 2,
        "importPath": "app.services.util",
        "description": "app.services.util",
        "peekOfCode": "def create_emag_product_from_fitness1_product(\n    fitness1_product: Fitness1Product,\n) -> EmagProduct:\n    \"\"\"\n    Creates an EmagProduct from a Fitness1Product.\n    Sets the:\n    \\n\n        - brand\n        - name\n        - ean",
        "detail": "app.services.util",
        "documentation": {}
    },
    {
        "label": "api_create",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_create():\n    \"\"\"\n    Endpoint to trigger the product creation process.\n    Accepts a JSON payload with optional parameters: 'pause' and 'batch_size'.\n    \"\"\"\n    data = request.get_json() or {}\n    pause = data.get(\"pause\", 1)\n    batch_size = data.get(\"batch_size\", 50)\n    add_log(\"API /create endpoint called.\")\n    result = {}",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_update",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_update():\n    \"\"\"\n    Endpoint to trigger the product update process.\n    Accepts a JSON payload with optional parameters: 'pause' and 'batch_size'.\n    Runs the update process synchronously.\n    \"\"\"\n    data = request.get_json() or {}\n    pause = data.get(\"pause\", 1)\n    batch_size = data.get(\"batch_size\", 50)\n    add_log(\"API /update endpoint called.\")",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_logs",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_logs():\n    \"\"\"\n    Returns the in-memory logs as a JSON response.\n    \"\"\"\n    logs = get_logs()\n    return jsonify({\"logs\": logs})\n@api_bp.route(\"/logs/clear\", methods=[\"POST\"])\ndef api_clear_logs():\n    clear_logs()\n    return jsonify({\"status\": \"success\", \"message\": \"Logs cleared.\"})",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_clear_logs",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_clear_logs():\n    clear_logs()\n    return jsonify({\"status\": \"success\", \"message\": \"Logs cleared.\"})\n@api_bp.route(\"/products/fitness1\", methods=[\"GET\"])\ndef api_get_fitness1_products():\n    # Use your existing function to fetch Fitness1 products\n    products = fetch_all_fitness1_products(\n        api_url=const.FITNESS1_API_URL, api_key=const.FITNESS1_API_KEY\n    )\n    # Optionally, you could process these into dicts if neededog",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_get_fitness1_products",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_get_fitness1_products():\n    # Use your existing function to fetch Fitness1 products\n    products = fetch_all_fitness1_products(\n        api_url=const.FITNESS1_API_URL, api_key=const.FITNESS1_API_KEY\n    )\n    # Optionally, you could process these into dicts if neededog\n    return jsonify({\"products\": products})\n@api_bp.route(\"/products/emag\", methods=[\"GET\"])\ndef api_get_emag_products():\n    products = fetch_all_emag_products(",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_get_emag_products",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_get_emag_products():\n    products = fetch_all_emag_products(\n        api_url=util.build_url(const.EMAG_URL, \"product_offer\", \"read\"),\n        headers=const.EMAG_HEADERS,\n        pause=1,\n    )\n    return jsonify({\"products\": products})\n@api_bp.route(\"/mappings\", methods=[\"GET\"])\ndef api_get_mappings():\n    mappings = Mapping.query.all()",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_get_mappings",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_get_mappings():\n    mappings = Mapping.query.all()\n    return jsonify({\"mappings\": {m.id: m.as_dict() for m in mappings}})\n@api_bp.route(\"/mappings\", methods=[\"POST\"])\ndef api_create_mapping():\n    data = request.get_json() or {}\n    fitness1_cat = data.get(\"fitness1_category\")\n    emag_cat = data.get(\"emag_category\")\n    if not (fitness1_cat and emag_cat):\n        return (",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_create_mapping",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_create_mapping():\n    data = request.get_json() or {}\n    fitness1_cat = data.get(\"fitness1_category\")\n    emag_cat = data.get(\"emag_category\")\n    if not (fitness1_cat and emag_cat):\n        return (\n            jsonify(\n                {\n                    \"status\": \"error\",\n                    \"message\": \"Both fitness1_category and emag_category are required.\",",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_update_mappings",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_update_mappings():\n    # Expect a list of mapping updates\n    data = request.get_json() or {}\n    updates = data.get(\"updates\", [])\n    if not updates:\n        return jsonify({\"status\": \"error\", \"message\": \"No updates provided.\"}), 400\n    for update in updates:\n        mapping_id = update.get(\"id\")\n        new_emag_cat = update.get(\"emag_category\")\n        if mapping_id and new_emag_cat:",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_get_categories",
        "kind": 2,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "def api_get_categories():\n    # Return the allowed EMAG categories (from the FitnessCategory table)\n    categories = FitnessCategory.query.all()\n    return jsonify({\"categories\": [cat.as_dict() for cat in categories]})",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "api_bp",
        "kind": 5,
        "importPath": "app.api",
        "description": "app.api",
        "peekOfCode": "api_bp = Blueprint(\"api\", __name__, url_prefix=\"/api\")\n@api_bp.route(\"/create\", methods=[\"POST\"])\ndef api_create():\n    \"\"\"\n    Endpoint to trigger the product creation process.\n    Accepts a JSON payload with optional parameters: 'pause' and 'batch_size'.\n    \"\"\"\n    data = request.get_json() or {}\n    pause = data.get(\"pause\", 1)\n    batch_size = data.get(\"batch_size\", 50)",
        "detail": "app.api",
        "documentation": {}
    },
    {
        "label": "login_required",
        "kind": 2,
        "importPath": "app.auth",
        "description": "app.auth",
        "peekOfCode": "def login_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not session.get(\"logged_in\"):\n            flash(\"Please log in to access this page.\", \"warning\")\n            return redirect(url_for(\"auth.login\"))\n        return f(*args, **kwargs)\n    return decorated_function\n@auth_bp.route(\"/login\", methods=[\"GET\", \"POST\"])\ndef login():",
        "detail": "app.auth",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "app.auth",
        "description": "app.auth",
        "peekOfCode": "def login():\n    if request.method == \"POST\":\n        username = request.form.get(\"username\")\n        password = request.form.get(\"password\")\n        # Create token: \"username:password\" then base64 encode it\n        token = f\"{username}:{password}\"\n        encoded_token = base64.b64encode(token.encode(\"utf-8\")).decode(\"utf-8\")\n        expected_token = current_app.config.get(\"EMAG_API_KEY\")\n        if encoded_token == expected_token:\n            session[\"logged_in\"] = True",
        "detail": "app.auth",
        "documentation": {}
    },
    {
        "label": "logout",
        "kind": 2,
        "importPath": "app.auth",
        "description": "app.auth",
        "peekOfCode": "def logout():\n    session.pop(\"logged_in\", None)\n    flash(\"Logged out successfully.\", \"success\")\n    return redirect(url_for(\"auth.login\"))\n# A placeholder dashboard route that requires authentication.\n@auth_bp.route(\"/dashboard\")\n@login_required\ndef dashboard():\n    return render_template(\"dashboard.html\")\n# Create an index route (or view) to redirect to the login page",
        "detail": "app.auth",
        "documentation": {}
    },
    {
        "label": "dashboard",
        "kind": 2,
        "importPath": "app.auth",
        "description": "app.auth",
        "peekOfCode": "def dashboard():\n    return render_template(\"dashboard.html\")\n# Create an index route (or view) to redirect to the login page\n@auth_bp.route(\"/\")\ndef index():\n    return redirect(url_for(\"auth.dashboard\"))",
        "detail": "app.auth",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "app.auth",
        "description": "app.auth",
        "peekOfCode": "def index():\n    return redirect(url_for(\"auth.dashboard\"))",
        "detail": "app.auth",
        "documentation": {}
    },
    {
        "label": "auth_bp",
        "kind": 5,
        "importPath": "app.auth",
        "description": "app.auth",
        "peekOfCode": "auth_bp = Blueprint(\"auth\", __name__)\n# A simple decorator to protect routes\ndef login_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not session.get(\"logged_in\"):\n            flash(\"Please log in to access this page.\", \"warning\")\n            return redirect(url_for(\"auth.login\"))\n        return f(*args, **kwargs)\n    return decorated_function",
        "detail": "app.auth",
        "documentation": {}
    },
    {
        "label": "scheduler",
        "kind": 5,
        "importPath": "app.extensions",
        "description": "app.extensions",
        "peekOfCode": "scheduler = APScheduler()",
        "detail": "app.extensions",
        "documentation": {}
    },
    {
        "label": "add_log",
        "kind": 2,
        "importPath": "app.logger",
        "description": "app.logger",
        "peekOfCode": "def add_log(message):\n    print(message)\n    logs.append(message)\ndef clear_logs():\n    logs.clear()\ndef get_logs():\n    return logs",
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "clear_logs",
        "kind": 2,
        "importPath": "app.logger",
        "description": "app.logger",
        "peekOfCode": "def clear_logs():\n    logs.clear()\ndef get_logs():\n    return logs",
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "get_logs",
        "kind": 2,
        "importPath": "app.logger",
        "description": "app.logger",
        "peekOfCode": "def get_logs():\n    return logs",
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "logs",
        "kind": 5,
        "importPath": "app.logger",
        "description": "app.logger",
        "peekOfCode": "logs = []\ndef add_log(message):\n    print(message)\n    logs.append(message)\ndef clear_logs():\n    logs.clear()\ndef get_logs():\n    return logs",
        "detail": "app.logger",
        "documentation": {}
    },
    {
        "label": "FitnessCategory",
        "kind": 6,
        "importPath": "app.models",
        "description": "app.models",
        "peekOfCode": "class FitnessCategory(db.Model):\n    __tablename__ = \"fitness_categories\"\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(255), unique=True, nullable=False)\n    def as_dict(self):\n        return {\"id\": self.id, \"name\": self.name}\nclass Mapping(db.Model):\n    __tablename__ = \"mappings\"\n    id = db.Column(db.Integer, primary_key=True)\n    fitness1_category = db.Column(db.String(255), nullable=False)",
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "kind": 6,
        "importPath": "app.models",
        "description": "app.models",
        "peekOfCode": "class Mapping(db.Model):\n    __tablename__ = \"mappings\"\n    id = db.Column(db.Integer, primary_key=True)\n    fitness1_category = db.Column(db.String(255), nullable=False)\n    # The EMAG category will be one of the allowed values from FitnessCategory.\n    emag_category = db.Column(db.String(255), nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.now(timezone.utc))\n    updated_at = db.Column(\n        db.DateTime,\n        default=datetime.now(timezone.utc),",
        "detail": "app.models",
        "documentation": {}
    },
    {
        "label": "update_job",
        "kind": 2,
        "importPath": "app.scheduler",
        "description": "app.scheduler",
        "peekOfCode": "def update_job():\n    print(\"Update job triggered at\", datetime.now())\n    run_update_process(pause=1, batch_size=50)\n@sched_bp.route(\"/schedule\", methods=[\"POST\"])\ndef schedule_update():\n    data = request.get_json() or {}\n    schedule_type = data.get(\"schedule_type\")\n    job_id = \"update_job\"\n    existing = scheduler.get_job(job_id)\n    if existing:",
        "detail": "app.scheduler",
        "documentation": {}
    },
    {
        "label": "schedule_update",
        "kind": 2,
        "importPath": "app.scheduler",
        "description": "app.scheduler",
        "peekOfCode": "def schedule_update():\n    data = request.get_json() or {}\n    schedule_type = data.get(\"schedule_type\")\n    job_id = \"update_job\"\n    existing = scheduler.get_job(job_id)\n    if existing:\n        scheduler.remove_job(job_id)\n    if schedule_type == \"time\":\n        time_str = data.get(\"time\")\n        if not time_str:",
        "detail": "app.scheduler",
        "documentation": {}
    },
    {
        "label": "get_job",
        "kind": 2,
        "importPath": "app.scheduler",
        "description": "app.scheduler",
        "peekOfCode": "def get_job():\n    job_id = \"update_job\"\n    job = scheduler.get_job(job_id)\n    if not job:\n        return jsonify({\"status\": \"error\", \"message\": \"No scheduled job found\"}), 404\n    job_data = job_to_dict(job)\n    # If it's a cron job with hour/minute parameters, compute the next run time.\n    if (\n        job_data[\"trigger\"] == \"cron\"\n        and job_data[\"hour\"] is not None",
        "detail": "app.scheduler",
        "documentation": {}
    },
    {
        "label": "cancel_job",
        "kind": 2,
        "importPath": "app.scheduler",
        "description": "app.scheduler",
        "peekOfCode": "def cancel_job():\n    job_id = \"update_job\"\n    job = scheduler.get_job(job_id)\n    if job:\n        scheduler.remove_job(job_id)\n        return jsonify({\"status\": \"success\", \"message\": \"Job canceled\"})\n    else:\n        return jsonify({\"status\": \"error\", \"message\": \"No job found to cancel\"}), 404\n@sched_bp.route(\"/trigger\", methods=[\"POST\"])\ndef trigger_update():",
        "detail": "app.scheduler",
        "documentation": {}
    },
    {
        "label": "trigger_update",
        "kind": 2,
        "importPath": "app.scheduler",
        "description": "app.scheduler",
        "peekOfCode": "def trigger_update():\n    try:\n        update_job()\n        return jsonify(\n            {\"status\": \"success\", \"message\": \"Update process triggered manually\"}\n        )\n    except Exception as e:\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 500",
        "detail": "app.scheduler",
        "documentation": {}
    },
    {
        "label": "sched_bp",
        "kind": 5,
        "importPath": "app.scheduler",
        "description": "app.scheduler",
        "peekOfCode": "sched_bp = Blueprint(\"sched\", __name__)\ndef update_job():\n    print(\"Update job triggered at\", datetime.now())\n    run_update_process(pause=1, batch_size=50)\n@sched_bp.route(\"/schedule\", methods=[\"POST\"])\ndef schedule_update():\n    data = request.get_json() or {}\n    schedule_type = data.get(\"schedule_type\")\n    job_id = \"update_job\"\n    existing = scheduler.get_job(job_id)",
        "detail": "app.scheduler",
        "documentation": {}
    },
    {
        "label": "get_engine",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def get_engine():\n    try:\n        # this works with Flask-SQLAlchemy<3 and Alchemical\n        return current_app.extensions['migrate'].db.get_engine()\n    except (TypeError, AttributeError):\n        # this works with Flask-SQLAlchemy>=3\n        return current_app.extensions['migrate'].db.engine\ndef get_engine_url():\n    try:\n        return get_engine().url.render_as_string(hide_password=False).replace(",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "get_engine_url",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def get_engine_url():\n    try:\n        return get_engine().url.render_as_string(hide_password=False).replace(\n            '%', '%%')\n    except AttributeError:\n        return str(get_engine().url).replace('%', '%%')\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "get_metadata",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def get_metadata():\n    if hasattr(target_db, 'metadatas'):\n        return target_db.metadatas[None]\n    return target_db.metadata\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "run_migrations_offline",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.  By skipping the Engine creation\n    we don't even need a DBAPI to be available.\n    Calls to context.execute() here emit the given string to the\n    script output.\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "run_migrations_online",
        "kind": 2,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "def run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n    \"\"\"\n    # this callback is used to prevent an auto-migration from being generated\n    # when there are no changes to the schema\n    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html\n    def process_revision_directives(context, revision, directives):\n        if getattr(config.cmd_opts, 'autogenerate', False):",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "config = context.config\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\nlogger = logging.getLogger('alembic.env')\ndef get_engine():\n    try:\n        # this works with Flask-SQLAlchemy<3 and Alchemical\n        return current_app.extensions['migrate'].db.get_engine()\n    except (TypeError, AttributeError):",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "logger = logging.getLogger('alembic.env')\ndef get_engine():\n    try:\n        # this works with Flask-SQLAlchemy<3 and Alchemical\n        return current_app.extensions['migrate'].db.get_engine()\n    except (TypeError, AttributeError):\n        # this works with Flask-SQLAlchemy>=3\n        return current_app.extensions['migrate'].db.engine\ndef get_engine_url():\n    try:",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "target_db",
        "kind": 5,
        "importPath": "migrations.env",
        "description": "migrations.env",
        "peekOfCode": "target_db = current_app.extensions['migrate'].db\n# other values from the config, defined by the needs of env.py,\n# can be acquired:\n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\ndef get_metadata():\n    if hasattr(target_db, 'metadatas'):\n        return target_db.metadatas[None]\n    return target_db.metadata\ndef run_migrations_offline():",
        "detail": "migrations.env",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "class Config:\n    DEBUG = os.environ.get(\"DEBUG\", \"False\") == \"True\"\n    SECRET_KEY = os.environ.get(\"SECRET_KEY\")\n    EMAG_API_KEY = os.environ.get(\"EMAG_API_KEY\")\n    FITNESS1_API_KEY = os.environ.get(\"FITNESS1_API_KEY\")\n    # Additional configuration options can be added here\n    # Database configuration\n    SQLALCHEMY_DATABASE_URI = os.environ.get(\"DATABASE_URL\")\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    # Flask app configuration",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "populate_fitness_categories",
        "kind": 2,
        "importPath": "initialize",
        "description": "initialize",
        "peekOfCode": "def populate_fitness_categories():\n    for cat in const.FITNESS_CATEGORIES:\n        # Check if the category already exists\n        if not FitnessCategory.query.filter_by(name=cat).first():\n            new_cat = FitnessCategory(name=cat)\n            db.session.add(new_cat)\n            print(f\"Adding category: {cat}\")\n    db.session.commit()\n    print(\"Categories populated successfully.\")\ndef populate_mappings():",
        "detail": "initialize",
        "documentation": {}
    },
    {
        "label": "populate_mappings",
        "kind": 2,
        "importPath": "initialize",
        "description": "initialize",
        "peekOfCode": "def populate_mappings():\n    fitness1_products = fetch_all_fitness1_products(\n        api_url=const.FITNESS1_API_URL, api_key=const.FITNESS1_API_KEY\n    )\n    all_fitness1_categories = util.get_current_fitness1_categories(fitness1_products)\n    # get a list of the fitness categories names\n    emag_categories_names = [cat.name for cat in FitnessCategory.query.all()]\n    # Step 6: Build a mapping between Fitness1 and EMAG categories\n    categories_mapping = util.build_mapping(\n        fitness1_categories=all_fitness1_categories,",
        "detail": "initialize",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "run",
        "description": "run",
        "peekOfCode": "app = create_app()\nif __name__ == \"__main__\":\n    app.run()",
        "detail": "run",
        "documentation": {}
    },
    {
        "label": "populate_fitness_categories",
        "kind": 2,
        "importPath": "scratch",
        "description": "scratch",
        "peekOfCode": "def populate_fitness_categories():\n    for cat in const.FITNESS_CATEGORIES:\n        # Check if the category already exists\n        if not FitnessCategory.query.filter_by(name=cat).first():\n            new_cat = FitnessCategory(name=cat)\n            db.session.add(new_cat)\n            print(f\"Adding category: {cat}\")\n    db.session.commit()\n    print(\"Categories populated successfully.\")\ndef populate_mappings():",
        "detail": "scratch",
        "documentation": {}
    },
    {
        "label": "populate_mappings",
        "kind": 2,
        "importPath": "scratch",
        "description": "scratch",
        "peekOfCode": "def populate_mappings():\n    fitness1_products = fetch_all_fitness1_products(\n        api_url=const.FITNESS1_API_URL, api_key=const.FITNESS1_API_KEY\n    )\n    all_fitness1_categories = util.get_current_fitness1_categories(fitness1_products)\n    # get a list of the fitness categories names\n    emag_categories_names = [cat.name for cat in FitnessCategory.query.all()]\n    # Step 6: Build a mapping between Fitness1 and EMAG categories\n    categories_mapping = util.build_mapping(\n        fitness1_categories=all_fitness1_categories,",
        "detail": "scratch",
        "documentation": {}
    },
    {
        "label": "handle_ip_log",
        "kind": 2,
        "importPath": "scratch",
        "description": "scratch",
        "peekOfCode": "def handle_ip_log(log_line: str) -> tuple[str, str, str] | None:\n    # Use a regex to capture the parts:\n    #   (\\w+)         matches one or more word characters for message_type\n    #   :\\s*          matches a colon followed by any whitespace\n    #   (.*?)         non-greedy match for the message text\n    #   \\s*\\[         matches any whitespace then an opening bracket\n    #   (.*?)         non-greedy match for the IP address\n    #   \\]            matches the closing bracket\n    \"\"\"\n    Handle a log line from the IP checker and return the message type,",
        "detail": "scratch",
        "documentation": {}
    },
    {
        "label": "update_job",
        "kind": 2,
        "importPath": "scratch",
        "description": "scratch",
        "peekOfCode": "def update_job():\n    print(\"Update job triggered at\", datetime.now())\nif __name__ == \"__main__\":\n    app = create_app()\n    with app.app_context():\n        pass",
        "detail": "scratch",
        "documentation": {}
    }
]